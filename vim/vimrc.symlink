" Disable arrows in normal mode
nnoremap <expr> <Up> ((bufname("%") is "[Command Line]")?("\<Up>"):(""))
nnoremap <expr> <Down> ((bufname("%") is "[Command Line]")?("\<Down>"):(""))
nnoremap <expr> <Left> ((bufname("%") is "[Command Line]")?("\<Left>"):(""))
nnoremap <expr> <Right> ((bufname("%") is "[Command Line]")?("\<Right>"):(""))
set wildmode=longest,list,full
set wildmenu

" Vim-Plug
call plug#begin('~/.vim/plugged')

" Sensible config
Plug 'tpope/vim-sensible'

" GIT changes
Plug 'airblade/vim-gitgutter'

" GIT plugin
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-rhubarb'

" Fuzzy finding
Plug 'junegunn/fzf.vim'

" Search through files
Plug 'mileszs/ack.vim'

" Many language highlighters
Plug 'sheerun/vim-polyglot'

" Async linting
Plug 'w0rp/ale'

" Like powerline and airline, but lighter
Plug 'itchyny/lightline.vim'

" Awesome colors
Plug 'lifepillar/vim-solarized8'

" PCGen Data file support
Plug 'PCGen/vim-pcgen'

" A tree-style browser
Plug 'scrooloose/nerdtree'

call plug#end()

set listchars=tab:»˙,trail:•,extends:>,precedes:<,nbsp:+
set relativenumber
set number
set ts=8
set sw=2
set expandtab
set colorcolumn=81
set list
set hls

" for any plugins that use this, make their keymappings use comma
" <Leader> is now comma
let mapleader = ","
let maplocalleader = ","

" ack -> ag
let g:ackprg = 'ag --vimgrep'
cnoreabbrev Ack Ack!
nnoremap <Leader>a :Ack!<Space>

" Some maps
nmap ; :Buffers<CR>

" Map ',' plus t or r to ack for files and tags
nmap <Leader>t :Files<CR>
nmap <Leader>r :Tags<CR>

" ALE
let g:ale_sign_warning = '▲'
let g:ale_sign_error = '✗'
"let g:ale_cpp_clangcheck_options = '-extra-arg="-std=c++11"'
let g:ale_cpp_clangtidy_options = '-std=c++11'
highlight link ALEWarningSign String
highlight link ALEErrorSign Title

" GitGutter
let g:gitgutter_sign_added = '∙'
let g:gitgutter_sign_modified = '∙'
let g:gitgutter_sign_removed = '∙'
let g:gitgutter_sign_modified_removed = '∙'

" NERDTree
autocmd StdinReadPre * let s:std_in=1
" Automatically open when no files are specified
autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
" Open when a directory is added
autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif
" Open the NERDTree with CTRL+n
map <C-n> :NERDTreeToggle<CR>
" Close vim when the only thing left is NERDTree
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

" Colors and shit yo!
set termguicolors
let g:solarized_termcolors=256
colorscheme solarized8_dark_flat

set noshowmode

let g:lightline = {
  \ 'colorscheme': 'solarized',
  \ 'active': {
  \   'left': [ ['mode', 'paste'],
  \             ['fugitive'],
  \             [ 'filename', 'modified' ]
  \           ],
  \   'right': [['lineinfo'],
  \             ['percent'],
  \             ['readonly', 'fileformat', 'fileencoding', 'filetype'],
  \             ['linter_warnings', 'linter_errors', 'linter_ok'],
  \             ]
  \ },
  \ 'component_function': {
  \   'fugitive': 'MyFugitive',
  \   'filename': 'MyFilename',
  \   'readonly': 'MyReadonly',
  \ },
  \ 'component_expand': {
  \   'linter_warnings': 'LightlineLinterWarnings',
  \   'linter_errors': 'LightlineLinterErrors',
  \   'linter_ok': 'LightlineLinterOK',
  \ },
  \ 'component_type': {
  \   'readonly': 'error',
  \   'linter_warnings': 'warning',
  \   'linter_errors': 'error'
  \ },
\ }


function! MyFugitive()
  if exists("*fugitive#head")
    let _ = fugitive#head()
    return strlen(_) ? "\ue0a0"._ : ''
  endif
  return ''
endfunction

function! MyReadonly()
  if &filetype == "help"
    return ""
  elseif &readonly
    return "\ue0a2"
  else
    return ""
  endif
endfunction

function! MyFilename()
  return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
       \ ('' != expand('%') ? expand('%') : '[NoName]')
endfunction

function! LightlineLinterWarnings() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ◆', all_non_errors)
endfunction

function! LightlineLinterErrors() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ✗', all_errors)
endfunction

function! LightlineLinterOK() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '✓ ' : ''
endfunction

autocmd User ALELint call s:MaybeUpdateLightline()

" Update and show lightline but only if it's visible (e.g., not in Goyo)
function! s:MaybeUpdateLightline()
  if exists('#lightline')
    call lightline#update()
  end
endfunction

" files in playbooks/ are ansible
au BufRead,BufNewFile */playbooks/*.yml set filetype=ansible

" set .md files as markdown
autocmd BufNewFile,BufReadPost *.md set filetype=markdown

" Align on leader+backslash
au FileType markdown vmap <Leader><Bslash> :EasyAlign*<Bar><Enter>
